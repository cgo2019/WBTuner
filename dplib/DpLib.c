#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <errno.h>
#include <assert.h>
#include <stdarg.h>
#include <string.h>
#include <sys/mman.h>
#include <stddef.h>
#include "DpLib.h"
#include "SamplingIO.h"
#include "SamplingStg.h"
#include "AggregateStg.h"
#include "DpUserApi.h"
#include "Sched.h"

// ------------------------------------ Declaration
extern int dpMainGlue(int argc, char *argv[]);
extern int errno;

// ------------------------------------ Definition
// Global data processing context
DPContext gDPContext;
// Global cross validation error
double gCVError;
// Global random auxialiary value 
static int gRSampleAuxVal[] = {
	0x67452301,
	0xEFCDAB89,
	0x98BADCFE,
	0x10325476,
	0xC3D2E1F0,
	0xFCEFA3F8,
	0x655B59C3,
	0x2AD7D2BB
};
// Global temp buffer
static char gTmpBuf[MAX_STR_LEN * 4];
// Global random variable index value.
// This is owned by each process and not
// shared.
static int gRSampleVarIdx;

// ------------------------------------ Internal function
void __attribute__ ((constructor)) dpInit()
{
	printf("DATA PROCESSING BEGIN:%d\n", getpid());

	// Initialize data processing context
	memset(&gDPContext, 0, sizeof(gDPContext));
	gDPContext.execStatus = DP_PARENT;

	// Init sampling io
	sioInit();

	// Init Scheduler
	schSchedInit();

	// Init parent process
	dpParentInit();
}

void __attribute__ ((destructor)) dpFini()
{
	// Need to do voting after sampling
	if (gDPContext.inSampling) {
		printf("Error: Need to do aggregation after sampling\n");
		dpExit(-1);
	}

	sioFini();
	
	if (!(gDPContext.execStatus & DP_FORKED_PARENT)) {
		while (1) {
			int status;
			pid_t donePID = wait(&status);

			if (donePID == -1 && errno == ECHILD) {
				break;
			}
		}
	}

	// We need to specify other forked parent process to dpExit as status 2
	if (gDPContext.execStatus & DP_FORKED_PARENT)
		dpExit(2);
	
	printf("DATA PROCESSING END\n");
	schDebug(-1);
}

void dpParentInit()
{
	int i;
	pthread_mutexattr_t mtxAttr;

	// Initialize shared table
	gDPContext.pSharedTab = (DPSharedTab *) 
		mmap(0, sizeof(DPSharedTab), 
			PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0);

	memset(gDPContext.pSharedTab, 0, sizeof(DPSharedTab));
	
	// Initialize shared mutex
	pthread_mutexattr_init(&mtxAttr);
	pthread_mutexattr_setpshared(&mtxAttr, PTHREAD_PROCESS_SHARED);

	// Initialize sync mutex
	for (i=0; i<MAX_MUTEX_NUM; i++) {
		gDPContext.pSharedTab->sypMtx[i] = (pthread_mutex_t *)
			mmap(0, sizeof(pthread_mutex_t),
					PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0);

		pthread_mutex_init(gDPContext.pSharedTab->sypMtx[i], &mtxAttr);
	}

	// Initialize aggregate shared memory mutex
	pthread_mutex_init(&gDPContext.pSharedTab->aggShmMtx, &mtxAttr);

	pthread_mutexattr_destroy(&mtxAttr);

	sioSARegionInit();

	//memset(gDPContext.pSharedTab, 0, offsetof(DPSharedTab, memsetBorder));

	//
	schParentInit();
}

// Before entering the sampling-voting region, do initializations
static void dpSVInit(int snum, int subsnum, va_list vl)
{
	// We are doing sampling now
	gDPContext.inSampling = 1;
	gDPContext.resultTab.todoNum = snum;
	gDPContext.resultTab.subTodoNum = subsnum;
	gDPContext.resultTab.resultTailIdx = 0;
	gDPContext.resultTab.resultHeadIdx = 0;
	gDPContext.resultTab.bestResultIdx = -1;
	gDPContext.resultTab.bestResultScore = 0;
	gRSampleVarIdx = 0;
	gDPContext.execStatus |= DP_SA_PARENT;

	// Cleanup the shared table for new sampling-aggregate region
	memset(gDPContext.pSharedTab, 0, offsetof(DPSharedTab, memsetBorder));

	fflush(stdout);
	fflush(stderr);
}

// Before leaving the sampling-aggregate region, do finalizations
// This needs to be done by all parent processes
static void dpSVFini()
{
	dpuFreeResultAll();

	// Only the parent of the sampling-aggregate region can delete
	// .bin and .parm files generated by its child processes
	if (gDPContext.execStatus & DP_SA_PARENT) {
		sioSARegionFini();
	}

	fflush(stdout);
	fflush(stderr);
}

// ------------------------------------ Glue function

// Sampling glue function
// The default sampling function is black box sampling
//
// Parm:
// 1. Sampling number
// 2. Sampling stratagy
void dpSampling(int snum, int subsnum, int stg, ...)
{
	va_list vl;
		
	if (gDPContext.inSampling) {
		printf("Error: Unable to do parallel sampling at same time\n");
		dpExit(-1);
	}

	va_start(vl, stg);

	// va_list is being passed and target aggregate variables'
	// information will be taken from va_list, so we continue
	// to take arguments from va_list
	dpSVInit(snum, subsnum, vl);

	switch (stg) {
		case S_USER_CB:
		{
			void *cbInitFunc = va_arg(vl, void *);
			void *cbFiniFunc = va_arg(vl, void *);
			void *cbFunc = va_arg(vl, void *);
			
			sstgFuncTab[stg](3, cbInitFunc, cbFiniFunc, cbFunc);
			break;
		}
		case S_RAND:
			sstgFuncTab[stg](snum);
			break;
		case S_MCMC_MAX:
		{
			void *scoreInitFunc = va_arg(vl, void *);
			void *scoreFiniFunc = va_arg(vl, void *);
			void *scoreFunc = va_arg(vl, void *);
			void *acceptProbFunc = va_arg(vl, void *);

			sstgFuncTab[stg](4, scoreInitFunc, scoreFiniFunc, scoreFunc,
				acceptProbFunc);

			break;
		}
		case S_MCMC_MIN:
		{
			void *scoreInitFunc = va_arg(vl, void *);
			void *scoreFiniFunc = va_arg(vl, void *);
			void *scoreFunc = va_arg(vl, void *);
			void *acceptProbFunc = va_arg(vl, void *);

			sstgFuncTab[stg](4, scoreInitFunc, scoreFiniFunc, scoreFunc,
				acceptProbFunc);

			break;
		}
		case S_CV:
		{
			int K = va_arg(vl, int);
			char *pTrainName = va_arg(vl, char *);
			void *cbFunc = va_arg(vl, void *);
			void *cbAcceptProbFunc = va_arg(vl, void *);

			// Set the sub todo number in order to prevent 
			// foking too many child processes
			gDPContext.resultTab.subTodoNum = (subsnum < MAX_CV_SUB_TODO) ? 
				gDPContext.resultTab.subTodoNum : MAX_CV_SUB_TODO;
		
			sstgFuncTab[stg](4, K, pTrainName, cbFunc, cbAcceptProbFunc);
			break;
		}
		default:
		{
			printf("Error<dpSampling>: Unknown strategy %d\n", stg);
			dpExit(-1);
		}
	}
	
	va_end(vl);
}

// Aggregation glue function
// Parm:
// 1. Callback (Only used by parent process)
// 2. Number of aggregating elements
// 3 - 6. 1st target variable info
// 7 - 10. 2nd target variable info
// ...
// Target variable info:
// Target pointer, Target type size, Number of elements, Strategy
void dpAggregate(int aggNum, ...)
{
	DPAggInfo *pAggInfo;
	DPChildTab *pChildTab;
	DPSharedTab *pSharedTab;;
	int i;

	// Make sure that we are in sampling process now
	if (!gDPContext.inSampling) {
		printf("Error: Need to do sampling before aggregation\n");
		dpExit(-1);
	} else if (gDPContext.execStatus != DP_CHILD) {
		// Parent set in sampling to 0
		gDPContext.inSampling = 0;
	}
	pSharedTab = gDPContext.pSharedTab;
	pAggInfo = pSharedTab->aggInfo;
	pChildTab = &gDPContext.childTab;
	gDPContext.pSharedTab->aggNum = aggNum;

	// Child process + cross validation
	if (gDPContext.execStatus == DP_CHILD && pChildTab->cvRunning) {
		void *trg[MAX_AGG_NUM];
		double validError = 0;
		va_list vl;
		
		va_start(vl, aggNum);

		for (i=0; i<aggNum; i++) {
			int tmp1;
			void *tmp2;
			
			trg[i] = va_arg(vl, void *);
			// Useless
			tmp1 = va_arg(vl, int);
			tmp1 = va_arg(vl, int);
			tmp1 = va_arg(vl, int);
			tmp1 = va_arg(vl, int);
			tmp2 = (void *) va_arg(vl, void *);
			tmp2 = (void *) va_arg(vl, void *);
			tmp2 = (void *) va_arg(vl, void *);
		}

		va_end(vl);
	
		switch (aggNum) {
			case 0:
				validError = pChildTab->cvCB(pChildTab->cvValidFileName);
				break;
			case 1:
				validError = pChildTab->cvCB(pChildTab->cvValidFileName, 
						trg[0]);
				break;
			case 2:
				validError = pChildTab->cvCB(pChildTab->cvValidFileName, 
						trg[0], trg[1]);
				break;
			case 3:
				validError = pChildTab->cvCB(pChildTab->cvValidFileName, 
						trg[0], trg[1], trg[2]);
				break;
			case 4:
				validError = pChildTab->cvCB(pChildTab->cvValidFileName, 
						trg[0], trg[1], trg[2], trg[3]);
				break;
			case 5:
				validError = pChildTab->cvCB(pChildTab->cvValidFileName, 
						trg[0], trg[1], trg[2], trg[3], 
						trg[4]);
				break;
			case 6:
				validError = pChildTab->cvCB(pChildTab->cvValidFileName, 
						trg[0], trg[1], trg[2], trg[3], 
						trg[4], trg[5]);
				break;
			case 7:
				validError = pChildTab->cvCB(pChildTab->cvValidFileName, 
						trg[0], trg[1], trg[2], trg[3], 
						trg[4], trg[5], trg[6]);
				break;
			case 8:
				validError = pChildTab->cvCB(pChildTab->cvValidFileName, 
						trg[0], trg[1], trg[2], trg[3], 
						trg[4], trg[5], trg[6], trg[7]);
				break;
			case 9:
				validError = pChildTab->cvCB(pChildTab->cvValidFileName, 
						trg[0], trg[1], trg[2], trg[3], 
						trg[4], trg[5], trg[6], trg[7],
						trg[8]);
				break;
			case 10:
				validError = pChildTab->cvCB(pChildTab->cvValidFileName, 
						trg[0], trg[1], trg[2], trg[3], 
						trg[4], trg[5], trg[6], trg[7],
						trg[8], trg[9]);
				break;
			case 11:
				validError = pChildTab->cvCB(pChildTab->cvValidFileName, 
						trg[0], trg[1], trg[2], trg[3], 
						trg[4], trg[5], trg[6], trg[7],
						trg[8], trg[9], trg[10]);
				break;
			case 12:
				validError = pChildTab->cvCB(pChildTab->cvValidFileName, 
						trg[0], trg[1], trg[2], trg[3], 
						trg[4], trg[5], trg[6], trg[7],
						trg[8], trg[9], trg[10], trg[11]);
				break;
			case 13:
				validError = pChildTab->cvCB(pChildTab->cvValidFileName, 
						trg[0], trg[1], trg[2], trg[3], 
						trg[4], trg[5], trg[6], trg[7],
						trg[8], trg[9], trg[10], trg[11],
						trg[12]);
				break;
			case 14:
				validError = pChildTab->cvCB(pChildTab->cvValidFileName, 
						trg[0], trg[1], trg[2], trg[3], 
						trg[4], trg[5], trg[6], trg[7],
						trg[8], trg[9], trg[10], trg[11],
						trg[12], trg[13]);
				break;
			case 15:
				validError = pChildTab->cvCB(pChildTab->cvValidFileName, 
						trg[0], trg[1], trg[2], trg[3], 
						trg[4], trg[5], trg[6], trg[7],
						trg[8], trg[9], trg[10], trg[11],
						trg[12], trg[13], trg[14]);
				break;
			case 16:
				validError = pChildTab->cvCB(pChildTab->cvValidFileName, 
						trg[0], trg[1], trg[2], trg[3], 
						trg[4], trg[5], trg[6], trg[7],
						trg[8], trg[9], trg[10], trg[11],
						trg[12], trg[13], trg[14], trg[15]);
				break;
			default:
				printf("Error<dpAggregate>: Too many aggregation targets, aggNum=%d, Max=%d\n",
						aggNum, MAX_AGG_NUM);
				dpExit(-1);
				break;
		}

		pthread_mutex_lock(pChildTab->cvMtx);

		*pChildTab->cvRemChildNum = (*pChildTab->cvRemChildNum) - 1;
		*pChildTab->cvValidError = (*pChildTab->cvValidError) + validError;

		if (*(pChildTab->cvRemChildNum) == 0) { // The last child process
			pthread_mutex_unlock(pChildTab->cvMtx);

			*pChildTab->cvValidError = 
				*pChildTab->cvValidError / (double)(pChildTab->K);
		} else {	// The others child processes
			pthread_mutex_unlock(pChildTab->cvMtx);
			dpExit(3);
		}

		// The last child process of each cross validation sampling 
		// writes the parameters result
		for (i=0; i<gRSampleVarIdx; i++) {
			switch (pChildTab->cvRSVarTab[i].tID) {
				case dpI:
					sprintf(gTmpBuf, "%d %lu %d\n", dpI, sizeof(int), 
							pChildTab->cvRSVarTab[i].intVal);
					break;
				case dpF:
					sprintf(gTmpBuf, "%d %lu %f\n", dpF, sizeof(float),
							pChildTab->cvRSVarTab[i].fltVal);
					break;
				case dpD:
					sprintf(gTmpBuf, "%d %lu %lf\n", dpD, sizeof(double),
							pChildTab->cvRSVarTab[i].dblVal);
					break;
				default:
					printf("Error<dpAggregate>: Unknow parm type=%d, parm index=%d\n",
							pChildTab->cvRSVarTab[i].tID, i);
					dpExit(-1);
			}
			sioWriteParm(gTmpBuf, getppid(), getpid());
		}

		va_start(vl, aggNum);

		// Write sampling result
		for (i=0; i<aggNum; i++) {
			void *trg = va_arg(vl, void *);
			int tID = va_arg(vl, int);
			int tSize = va_arg(vl, int);
			int nmemb = va_arg(vl, int);
			AStg stg = va_arg(vl, int);

			astgFuncPtr cbInit = va_arg(vl, astgFuncPtr);
			astgFuncPtr cbFini = va_arg(vl, astgFuncPtr);
			astgFuncPtr cb = va_arg(vl, astgFuncPtr);

			pAggInfo[i].trg = trg;
			pAggInfo[i].tID = tID;
			pAggInfo[i].tSize = tSize;
			pAggInfo[i].nmemb = nmemb;
			pAggInfo[i].stg = stg;

			if (stg <= A_MIN) {
				if (sioWriteResult(trg, nmemb, tSize, getppid(), getpid()) < 0)
					dpExit(-1);
			} else {
				printf("Error<dpAggregate>:"
					" Cross validation currently does not support incremental "
					"aggregation\n");
				dpExit(-1);
			}
		}
		
		va_end(vl);
	
		// Use the index of (aggregation variables number + 1) to store
		// the validation error.
		pAggInfo[aggNum].trg = &pChildTab->cvValidError;
		pAggInfo[aggNum].tID = dpD;
		pAggInfo[aggNum].tSize = sizeof(double);
		pAggInfo[aggNum].nmemb = 1;
		pAggInfo[aggNum].stg = 0;
		
		// Write the validation result
		if (sioWriteResult(pChildTab->cvValidError, 1, sizeof(double), 
				getppid(), getpid()) < 0)
			dpExit(-1);
			
		// Set the random variable number directly
		pSharedTab->rRandVarNum = gRSampleVarIdx;

		// Subtract the active child process number by 1
		pthread_mutex_lock(pSharedTab->sypMtx[1]);
		pSharedTab->syActiveChildNum--;
		pthread_mutex_unlock(pSharedTab->sypMtx[1]);

		// Exit normally
		dpExit(0);
	} 
	// Child process
	else if (gDPContext.execStatus == DP_CHILD) {
		va_list vl;
		int shmIdx = -1;
		
		va_start(vl, aggNum);

		// Write sampling result
		for (i=0; i<aggNum; i++) {
			void *trg = va_arg(vl, void *);
			int tID = va_arg(vl, int);
			int tSize = va_arg(vl, int);
			int nmemb = va_arg(vl, int);
			int stg = va_arg(vl, int);
			astgFuncPtr cbInit = va_arg(vl, astgFuncPtr);
			astgFuncPtr cbFini = va_arg(vl, astgFuncPtr);
			astgFuncPtr cb = va_arg(vl, astgFuncPtr);

			pAggInfo[i].trg = trg;
			pAggInfo[i].tID = tID;
			pAggInfo[i].tSize = tSize;
			pAggInfo[i].nmemb = nmemb;
			pAggInfo[i].stg = stg;
	
			switch (stg) {
				case A_USER_CB:
				case A_AVG:
				case A_MJ_VOTE:
				case A_MAX:
				case A_MIN:
					if (sioWriteResult(trg, nmemb, tSize, getppid(), getpid()) < 0)
						dpExit(-1);
					break;
				case A_AVG_MEM:
				case A_MJ_VOTE_MEM:
					if (shmIdx == -1) {
						pthread_mutex_lock(&pSharedTab->aggShmMtx);
						shmIdx = pSharedTab->aggShmNum++;
						pthread_mutex_unlock(&pSharedTab->aggShmMtx);
					}
					astgFuncTab[stg](i, trg, shmIdx);
					break;
				case A_MAX_MEM:
				case A_MIN_MEM:
					if (shmIdx == -1) {
						pthread_mutex_lock(&pSharedTab->aggShmMtx);
						shmIdx = pSharedTab->aggShmNum++;
						pthread_mutex_unlock(&pSharedTab->aggShmMtx);
					}
					astgFuncTab[stg](i, trg, shmIdx, cbInit, cbFini, cb);
					break;
				default:
				{
					printf("Error<dpAggregate>: Unknown strategy %d\n", stg);
					dpExit(-1);
				}
			}
		}
		va_end(vl);
		
		// Set the random variable number directly
		pSharedTab->rRandVarNum = gRSampleVarIdx;

		// Subtract the active child process number by 1
		pthread_mutex_lock(pSharedTab->sypMtx[1]);
		pSharedTab->syActiveChildNum--;
		pthread_mutex_unlock(pSharedTab->sypMtx[1]);

		if (shmIdx == -1) {
			// Exit normally
			dpExit(0);
		} else {
			// Exit with status = SHM_EXIT_STATUS_BASE + shmIdx
			dpExit(SHM_EXIT_STATUS_BASE + shmIdx);
		}
	}
	// Parent process do aggregation
	else if (gDPContext.execStatus & DP_SA_PARENT) {
		va_list vl;

		va_start(vl, aggNum);

		for (i=0; i<aggNum; i++) {
			void *trg = va_arg(vl, void *);
			int tID = va_arg(vl, int);
			int tSize = va_arg(vl, int);
			int nmemb = va_arg(vl, int);
			int stg = va_arg(vl, int);
			
			astgFuncPtr cbInit = va_arg(vl, astgFuncPtr);
			astgFuncPtr cbFini = va_arg(vl, astgFuncPtr);
			astgFuncPtr cb = va_arg(vl, astgFuncPtr);

			pAggInfo[i].trg = trg;
			pAggInfo[i].tID = tID;
			pAggInfo[i].tSize = tSize;
			pAggInfo[i].nmemb = nmemb;
			pAggInfo[i].stg = stg;

			// Handle the target variable with supported strategy
			switch (stg) {
				case A_USER_CB:
					assert(cb && "Need user callback");
					cb(gDPContext.resultTab.resultTailIdx, trg);
					break;
				case A_AVG:
				case A_MJ_VOTE:
					astgFuncTab[stg](i, trg);
					break;
				case A_MAX:
				{
					assert(cbInit && cbFini && cb);
					// User-implemented scoring-related functions
					// 1. Function executing before scoring function
					// 2. Function executing after scoring function
					// 3. Scoring function
					astgFuncTab[stg](i, trg, cbInit, cbFini, cb);
					break;
				}
				case A_MIN:
				{
					assert(cbInit && cbFini && cb);
					// User-implemented scoring-related functions
					// 1. Function executing before scoring function
					// 2. Function executing after scoring function
					// 3. Scoring function
					astgFuncTab[stg](i, trg, cbInit, cbFini, cb);
					break;
				}
				case A_AVG_MEM:
				case A_MJ_VOTE_MEM:
				case A_MAX_MEM:
				case A_MIN_MEM:
					astgFuncTab[stg](i, trg);
					break;
				default:
				{
					printf("Error<dpAggregate>: Unknown strategy %d\n", stg);
					dpExit(-1);
				}
			}
		}
		
		va_end(vl);
		
		dpSVFini();
	} else {
		dpSVFini();
	}

	printf("Done Aggregation\n");
}

// Cross child process sync glue function. Totally four mutex locks are used.
// Mutext 0: gDPContext.pSharedTab->sySyncChildNum
// Mutext 1: gDPContext.pSharedTab->sySyncChildDoneNum
// Mutext 2: gDPContext.pSharedTab->syActiveChildNum
// Mutext 3: Preventing slave child processes from leaving synchronization
//					 before master process finish sync works.
void dpSync(void *trg, TypeID tID, int tSize, int nmemb, ...)
{
	int i;
	int activeChildNum;

	if (gDPContext.execStatus != DP_CHILD)
		return;

	// Checkpoint 1:
	// Process needs to wait here until all sync processes
	// reach this checkpoint
	pthread_mutex_lock(gDPContext.pSharedTab->sypMtx[0]);
	gDPContext.pSharedTab->sySyncChildNum++;
	pthread_mutex_unlock(gDPContext.pSharedTab->sypMtx[0]);
	
	while (1) {
		int syncChildNum;
		
		pthread_mutex_lock(gDPContext.pSharedTab->sypMtx[0]);
		syncChildNum = gDPContext.pSharedTab->sySyncChildNum;
		pthread_mutex_unlock(gDPContext.pSharedTab->sypMtx[0]);

		pthread_mutex_lock(gDPContext.pSharedTab->sypMtx[2]);
		activeChildNum = gDPContext.pSharedTab->syActiveChildNum;
		pthread_mutex_unlock(gDPContext.pSharedTab->sypMtx[2]);
	
		if (syncChildNum == activeChildNum) {
			break;
		}
	}

	// Checkpoint 2:
	// The first process which acquires mutex is responsible
	// for the synchronization. Which means this process
	// is master process.
	pthread_mutex_lock(gDPContext.pSharedTab->sypMtx[1]);
	
	if (gDPContext.pSharedTab->sySyncChildDoneNum == 0) {
		int syncChildDoneNum;
		
		gDPContext.pSharedTab->sySyncChildDoneNum++;
		// Acquire mutex #2 to lock the rest processes that take
		// the false branch
		pthread_mutex_lock(gDPContext.pSharedTab->sypMtx[3]);
	
		// Unlock mutex #0 to let other processes in
		pthread_mutex_unlock(gDPContext.pSharedTab->sypMtx[1]);

		while (1) {	
			pthread_mutex_lock(gDPContext.pSharedTab->sypMtx[1]);
			syncChildDoneNum = gDPContext.pSharedTab->sySyncChildDoneNum;
			pthread_mutex_unlock(gDPContext.pSharedTab->sypMtx[1]);

			pthread_mutex_lock(gDPContext.pSharedTab->sypMtx[2]);
			activeChildNum = gDPContext.pSharedTab->syActiveChildNum;
			pthread_mutex_unlock(gDPContext.pSharedTab->sypMtx[2]);

			// Do synchronization!!!
			if (syncChildDoneNum == activeChildNum) {
				va_list vl;
				void (*syncFunc)(int);

				gDPContext.pSharedTab->sySyncData = 
					(void **) malloc(syncChildDoneNum * sizeof(void *));
				
				gDPContext.pSharedTab->sySyncPID = 
					(int *) malloc(syncChildDoneNum * sizeof(int));

				// Store master process's data address and pid at last position
				gDPContext.pSharedTab->sySyncData[syncChildDoneNum - 1] = trg;
				gDPContext.pSharedTab->sySyncPID[syncChildDoneNum - 1] = getpid();

				if (!nmemb) {
					for (i=0; i<syncChildDoneNum-1; i++)
						gDPContext.pSharedTab->sySyncData[i] = malloc(tSize);
				} else {
					for (i=0; i<syncChildDoneNum-1; i++)
						gDPContext.pSharedTab->sySyncData[i] = malloc(nmemb * tSize);
				}

				if (sioReadSyncDataAll(
							syncChildDoneNum, nmemb, tSize, getppid()) < 0) 
				{
					printf("Error<dpSync>: Sync failed\n");
					dpExit(-1);
				}

				va_start(vl, trg);

				syncFunc = va_arg(vl, void *);
				syncFunc(syncChildDoneNum);

				va_end(vl);

				break;
			}
		}

		// Cleanup
		for (i=0; i<syncChildDoneNum-1; i++) {
			free(gDPContext.pSharedTab->sySyncData[i]);
		}
		free(gDPContext.pSharedTab->sySyncData);
		gDPContext.pSharedTab->sySyncData = NULL;
		gDPContext.pSharedTab->sySyncChildNum = 0;
		gDPContext.pSharedTab->sySyncChildDoneNum = 0;
		sioSyncFini(getppid());

		// Unlock slave processes in false branch after sych work
		pthread_mutex_unlock(gDPContext.pSharedTab->sypMtx[3]);
	} else {
		sioWriteSyncData(trg, nmemb, tSize, getppid(), getpid());
		gDPContext.pSharedTab->sySyncChildDoneNum++;
		pthread_mutex_unlock(gDPContext.pSharedTab->sypMtx[1]);

		// Processes which take false branch will be locked here
		// and wait for master process to finish sync work.
		pthread_mutex_lock(gDPContext.pSharedTab->sypMtx[3]);
		pthread_mutex_unlock(gDPContext.pSharedTab->sypMtx[3]);
	}
	
	if (sioSplitSyncCheck(getppid(), getpid())) {
		dpuSplit();
	}
}

// Check glue function
void dpCheck(int (*cb)(void *, ...), int chkNum, ...)
{
	va_list vl;
	int i, cc;
	void *trg[MAX_AGG_NUM];

	if (gDPContext.execStatus != DP_CHILD)
		return;

	va_start(vl, chkNum);

	for (i=0; i<chkNum; i++) {
		trg[i] = va_arg(vl, void *);
	}
	
	va_end(vl);

	switch (chkNum) {
		case 0:
			cc = cb(NULL);
			break;
		case 1:
			cc = cb(trg[0]);
			break;
		case 2:
			cc = cb(trg[0], trg[1]);
			break;
		case 3:
			cc = cb(trg[0], trg[1], trg[2]);
			break;
		case 4:
			cc = cb(trg[0], trg[1], trg[2], trg[3]);
			break;
		case 5:
			cc = cb(trg[0], trg[1], trg[2], trg[3], 
					trg[4]);
			break;
		case 6:
			cc = cb(trg[0], trg[1], trg[2], trg[3], 
					trg[4], trg[5]);
			break;
		case 7:
			cc = cb(trg[0], trg[1], trg[2], trg[3], 
					trg[4], trg[5], trg[6]);
			break;
		case 8:
			cc = cb(trg[0], trg[1], trg[2], trg[3], 
					trg[4], trg[5], trg[6], trg[7]);
			break;
		case 9:
			cc = cb(trg[0], trg[1], trg[2], trg[3], 
					trg[4], trg[5], trg[6], trg[7],
					trg[8]);
			break;
		case 10:
			cc = cb(trg[0], trg[1], trg[2], trg[3], 
					trg[4], trg[5], trg[6], trg[7],
					trg[8], trg[9]);
			break;
		case 11:
			cc = cb(trg[0], trg[1], trg[2], trg[3], 
					trg[4], trg[5], trg[6], trg[7],
					trg[8], trg[9], trg[10]);
			break;
		case 12:
			cc = cb(trg[0], trg[1], trg[2], trg[3], 
					trg[4], trg[5], trg[6], trg[7],
					trg[8], trg[9], trg[10], trg[11]);
			break;
		case 13:
			cc = cb(trg[0], trg[1], trg[2], trg[3], 
					trg[4], trg[5], trg[6], trg[7],
					trg[8], trg[9], trg[10], trg[11],
					trg[12]);
			break;
		case 14:
			cc = cb(trg[0], trg[1], trg[2], trg[3], 
					trg[4], trg[5], trg[6], trg[7],
					trg[8], trg[9], trg[10], trg[11],
					trg[12], trg[13]);
			break;
		case 15:
			cc = cb(trg[0], trg[1], trg[2], trg[3], 
					trg[4], trg[5], trg[6], trg[7],
					trg[8], trg[9], trg[10], trg[11],
					trg[12], trg[13], trg[14]);
			break;
		case 16:
			cc = cb(trg[0], trg[1], trg[2], trg[3], 
					trg[4], trg[5], trg[6], trg[7],
					trg[8], trg[9], trg[10], trg[11],
					trg[12], trg[13], trg[14], trg[15]);
			break;
		default:
			printf("Error<dpCheck>: Too many checking targets, chkNum=%d Max=%d\n",
				chkNum, MAX_AGG_NUM);
			dpExit(-1);
			break;
	}

	// Check failed
	if (cc == 0) {
		dpExit(1);
	}
	
}

// Random sample int glue function
int dpRSI(int lo, int hi, void *cb)
{
	int rsNum;
	DPSharedTab *pSharedTab = gDPContext.pSharedTab;

	// Set the static part of random sample variable lo and hi
	if (!pSharedTab->rLoS[gRSampleVarIdx].tID) {
		pSharedTab->rLoS[gRSampleVarIdx].tID = dpI;
		pSharedTab->rHiS[gRSampleVarIdx].tID = dpI;
		pSharedTab->rLoS[gRSampleVarIdx].intVal = lo;
		pSharedTab->rHiS[gRSampleVarIdx].intVal = hi;
//		strcpy(pSharedTab->rRandVarName[gRSampleVarIdx], rsVarName);
	}

	// User set the lo to a specified value
	if (pSharedTab->rLoD[gRSampleVarIdx].tID == dpI) {
		lo = pSharedTab->rLoD[gRSampleVarIdx].intVal;
	}

	// User set the hi to a specified value
	if (pSharedTab->rHiD[gRSampleVarIdx].tID == dpI) {
		hi = pSharedTab->rHiD[gRSampleVarIdx].intVal;
	}
	
	rsNum = dpRSampleInt(lo, hi);

	if (gDPContext.execStatus == DP_CHILD) {
		DPChildTab *pChildTab = &gDPContext.childTab;

		// Normal execution 
		if (!pChildTab->cvRunning) {
			sprintf(gTmpBuf, "%d %lu %d\n", dpI, sizeof(int), rsNum);
			sioWriteParm(gTmpBuf, getppid(), getpid());
		}
		// Handling cross validation
		else {
			pthread_mutex_lock(pChildTab->cvMtx);
			
			// First child process comes in
			if (pChildTab->cvRSVarTab[gRSampleVarIdx].tID == 0) {
				pChildTab->cvRSVarTab[gRSampleVarIdx].tID = dpI;
				pChildTab->cvRSVarTab[gRSampleVarIdx].intVal = rsNum;
			} 
			// The others child processes
			else {
				rsNum = pChildTab->cvRSVarTab[gRSampleVarIdx].intVal;
			}
			
			pthread_mutex_unlock(pChildTab->cvMtx);
		}
	} 	
	
//	printf("random int=%d lo=%d hi=%d isParent=%d name=%s\n", 
//		randNum, lo, hi, gDPContext.isParent,
//		pSharedTab->rRandVarName[gRSampleVarIdx]);

	gRSampleVarIdx++;

	return rsNum;
}

// Random sample float glue function
float dpRSF(float lo, float hi, void *cb)
{
	float rsNum;
	DPSharedTab *pSharedTab = gDPContext.pSharedTab;

	// Set the static part of random sample variable lo and hi
	if (!pSharedTab->rLoS[gRSampleVarIdx].tID) {
		pSharedTab->rLoS[gRSampleVarIdx].tID = dpF;
		pSharedTab->rHiS[gRSampleVarIdx].tID = dpF;
		pSharedTab->rLoS[gRSampleVarIdx].fltVal = lo;
		pSharedTab->rHiS[gRSampleVarIdx].fltVal = hi;
//		strcpy(pSharedTab->rRandVarName[gRSampleVarIdx], rsVarName);
	}

	// User set the lo to a specified value
	if (pSharedTab->rLoD[gRSampleVarIdx].tID == dpF) {
		lo = pSharedTab->rLoD[gRSampleVarIdx].fltVal;
	}

	// User set the hi to a specified value
	if (pSharedTab->rHiD[gRSampleVarIdx].tID == dpF) {
		hi = pSharedTab->rHiD[gRSampleVarIdx].fltVal;
	}

	rsNum = dpRSampleReal(lo, hi);

	if (gDPContext.execStatus == DP_CHILD) {
		DPChildTab *pChildTab = &gDPContext.childTab;

		// Normal execution 
		if (!pChildTab->cvRunning) {
			sprintf(gTmpBuf, "%d %lu %lf\n", dpF, sizeof(double), rsNum);
			sioWriteParm(gTmpBuf, getppid(), getpid());
		}
		// Handling cross validation
		else {
			pthread_mutex_lock(pChildTab->cvMtx);
			
			// First child process comes in
			if (pChildTab->cvRSVarTab[gRSampleVarIdx].tID == 0) {
				pChildTab->cvRSVarTab[gRSampleVarIdx].tID = dpF;
				pChildTab->cvRSVarTab[gRSampleVarIdx].fltVal = rsNum;
			} 
			// The others child processes
			else {
				rsNum = pChildTab->cvRSVarTab[gRSampleVarIdx].fltVal;
			}
			
			pthread_mutex_unlock(pChildTab->cvMtx);
		}
	}

//	printf("random float=%lf lo=%lf hi=%lf isParent=%d name=%s\n", 
//		randNum, lo, hi, gDPContext.isParent, 
//		pSharedTab->rRandVarName[gRSampleVarIdx]);

	gRSampleVarIdx++;
	
	return rsNum;
}

// Random sample double glue function
double dpRSD(double lo, double hi, void *cb)
{
	double rsNum;
	DPSharedTab *pSharedTab = gDPContext.pSharedTab;

	// Set the static part of random sample variable lo and hi
	if (!pSharedTab->rLoS[gRSampleVarIdx].tID) {
		pSharedTab->rLoS[gRSampleVarIdx].tID = dpD;
		pSharedTab->rHiS[gRSampleVarIdx].tID = dpD;
		pSharedTab->rLoS[gRSampleVarIdx].dblVal = lo;
		pSharedTab->rHiS[gRSampleVarIdx].dblVal = hi;
	//	strcpy(pSharedTab->rRandVarName[gRSampleVarIdx], rsVarName);
	}

	// User set the lo to a specified value
	if (pSharedTab->rLoD[gRSampleVarIdx].tID == dpD) {
		lo = pSharedTab->rLoD[gRSampleVarIdx].dblVal;
	}

	// User set the hi to a specified value
	if (pSharedTab->rHiD[gRSampleVarIdx].tID == dpD) {
		hi = pSharedTab->rHiD[gRSampleVarIdx].dblVal;
	}

	rsNum = dpRSampleReal(lo, hi);

	if (gDPContext.execStatus == DP_CHILD) {
		DPChildTab *pChildTab = &gDPContext.childTab;

		// Normal execution 
		if (!pChildTab->cvRunning) {
			sprintf(gTmpBuf, "%d %lu %lf\n", dpD, sizeof(double), rsNum);
			sioWriteParm(gTmpBuf, getppid(), getpid());
		}
		// Handling cross validation
		else {
			pthread_mutex_lock(pChildTab->cvMtx);
			
			// First child process comes in
			if (pChildTab->cvRSVarTab[gRSampleVarIdx].tID == 0) {
				pChildTab->cvRSVarTab[gRSampleVarIdx].tID = dpD;
				pChildTab->cvRSVarTab[gRSampleVarIdx].dblVal = rsNum;
			} 
			// The others child processes
			else {
				rsNum = pChildTab->cvRSVarTab[gRSampleVarIdx].dblVal;
			}
			
			pthread_mutex_unlock(pChildTab->cvMtx);
		}
	}

//	printf("random double=%lf lo=%lf hi=%lf isParent=%d name=%s\n", 
//		randNum, lo, hi, gDPContext.isParent, 
//		pSharedTab->rRandVarName[gRSampleVarIdx]);
	
	gRSampleVarIdx++;
	
	return rsNum;
}

// TODO
// Random sample object glue function
void dpRSO(void *obj)
{

}

int dpRSampleInt(int lo, int hi)
{
	double rsNum;
	struct timespec t;
	int seed;
	int i;

	clock_gettime(CLOCK_MONOTONIC, &t);

	i = t.tv_nsec;

	seed = i * (getpid() | (getpid() << 16));
	seed *= gRSampleAuxVal[seed & 7] * getpid() * getpid() * ((int)&rsNum);

	srand(seed);
	
	if (hi < lo) {
		int swap = hi;
		hi = lo;
		lo = swap;
	}

	rsNum = rand() % (hi - lo + 1);

	rsNum += lo;

	return rsNum;
}

double dpRSampleReal(double lo, double hi)
{
	double rsNum;
	struct timespec t;
	int seed;
	int i;

	clock_gettime(CLOCK_MONOTONIC, &t);

	i = t.tv_nsec * getpid();
	seed = i * (getpid() | (getpid() << 16));
	seed *= gRSampleAuxVal[seed & 7] * getpid() * getpid() * ((int)&rsNum);

	srand(seed);

	if (hi < lo) {
		double swap = hi;
		hi = lo;
		lo = swap;
	}

	for (i=0; i<=gRSampleVarIdx; i++) {
		rand();
	}

	i = rand();

	rsNum = ((double)i / (double)RAND_MAX) * (hi - lo) + lo;

	return rsNum;
}

void dpExpInternal(char *expName, TypeID tID, ...)
{
	va_list vl;
	int idx;
	DPExpVar *pExpVar = gDPContext.resultTab.expTab;
	int expIdx = gDPContext.resultTab.expIdx;

	for (idx=0; idx<expIdx; idx++) {
		if (strcmp(expName, pExpVar[idx].pName) == 0) {
			break;
		}
	}

	if (idx == expIdx) {
		strcat(pExpVar[idx].pName, expName);
		gDPContext.resultTab.expIdx++;
	}

	pExpVar[idx].var.tID = tID;
		
	va_start(vl, tID);

	switch (tID) {
		case dpC:
		{
			int val = va_arg(vl, int);
			pExpVar[idx].var.charVal = (char) val;
			break;
		}
		case dpS:
		{
			int val = va_arg(vl, int);
			pExpVar[idx].var.shortVal = (short) val;
			break;
		}
		case dpI:
		{
			int val = va_arg(vl, int);
			pExpVar[idx].var.intVal = val;
			break;
		}
		case dpL:
		{	
			long long val = va_arg(vl, long long);
			pExpVar[idx].var.longVal = val;
			break;
		}
		case dpF:
		{	
			double val = va_arg(vl, double);
			pExpVar[idx].var.fltVal = (float) val;
			break;
		}
		case dpD:
		{	
			double val = va_arg(vl, double);
			pExpVar[idx].var.dblVal = val;
			break;
		}
		case dpUC:
		{
			unsigned int val = va_arg(vl, unsigned int);
			pExpVar[idx].var.ucharVal = (unsigned char) val;
			break;
		}
		case dpUS:
		{
			unsigned int val = va_arg(vl, unsigned int);
			pExpVar[idx].var.ushortVal = (unsigned short) val;
			break;
		}
		case dpUI:
		{
			unsigned int val = va_arg(vl, unsigned int);
			pExpVar[idx].var.uintVal = val;
			break;
		}
		case dpP:
		case dpUL:
		{
			unsigned long long val = va_arg(vl, unsigned long long);
			pExpVar[idx].var.ulongVal = val;
			break;
		}
		default:
			break;
	}

	va_end(vl);
}

void *dpLoadInternal(char *expName)
{
	int idx;
	DPExpVar *pExpVar = gDPContext.resultTab.expTab;
	int expIdx = gDPContext.resultTab.expIdx;

	for (idx=0; idx<expIdx; idx++) {
		if (strcmp(expName, pExpVar[idx].pName) == 0) {
			break;
		}
	}

	if (idx == expIdx)
		return NULL;

	return (void *)&pExpVar[idx];

#if 0
	tID = pExpVar[idx].var.tID;
		
	switch (tID) {
		case dpC:
		{
			*((char *)trg) = gDPContext.loadTab[idx].charVal;
			break;
		}
		case dpS:
		{
			*((short *)trg) = gDPContext.loadTab[idx].shortVal;
			break;
		}
		case dpI:
		{
			*((int *)trg) = gDPContext.loadTab[idx].intVal;
			break;
		}
		case dpL:
		{	
			*((long long *)trg) = gDPContext.loadTab[idx].longVal;
			break;
		}
		case dpF:
		{	
			*((float *)trg) = gDPContext.loadTab[idx].fltVal;
			break;
		}
		case dpD:
		{	
			*((double *)trg) = gDPContext.loadTab[idx].dblVal;
			break;
		}
		case dpUC:
		{
			*((unsigned char *)trg) = gDPContext.loadTab[idx].ucharVal;
			break;
		}
		case dpUS:
		{
			*((unsigned short *)trg) = gDPContext.loadTab[idx].ushortVal;
			break;
		}
		case dpUI:
		{
			*((unsigned int *)trg) = gDPContext.loadTab[idx].uintVal;
			break;
		}
		case dpP:
		case dpUL:
		{	
			*((unsigned long long *)trg) = gDPContext.loadTab[idx].ulongVal;
			break;
		}
		default:
			break;
	}
#endif
}

int dpGetStatus()
{
	return gDPContext.execStatus;
}

void __attribute__ ((noinline)) dpExit(int status)
{
	schSched(S_EXIT, 0);
	_exit(status);		
}
