This is the source branch of WBTuner

1. Download:
- git clone https://github.com/evans14641/WBTuner/

1.1 Technical report uploaded
- Please see the technical report for more experiment details
- Supplementary Materials

2. Installing WBTuner
- goto /path/to/WBTuner/dplib
- make clean
- make
- export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/WBTuner/dplib

3. Using WBTuner
After compiling, run the executable as the original program.
For example, if original program execution is "./a.out -a -b", then
for WBTuner, just type "./a.out -a -b".

---------------------------------------------------------------------------------

3.1 Example 1
- cd /path/to/WBTuner/test/examples/example1
- Edit Makefile path
  - line 6: LDLIB = -L/path/to/WBTuner/dplib
  - line 9: INCPATH = -I/path/to/WBTuner/dplib
- Primitives explanation:
  - dpSampling
    Arg1: # samples
    Arg2: max # of concurrent sampling processes, can be any number and 32
          is used here
    Arg3: random sampling strategy
    
  - dpRSF
    - Get a random sample of floating point number
    Arg1-2: sampling boundary
    Arg3: user defined distribution
  
  - dpAggregate
    Arg1: # target aggregation variables
    Arg2-9: info of 1st target aggregation variable
    Arg2: target variable for aggregation
    Arg3: variable's element type; float
    Arg4: variable's element size
    Arg5: # elements
    Arg6: aggregation strategy, use average here
    Arg7-9: NULL because averaging is support by WBTuner by default
    
- Explanation:
  example1.c is a simple example to trigger samping. dpSampling at line 10
  is used to trigger sampling and dpRSF at line 11 is used to sample
  variable f. Finally, dpAggregate at line 18 is used to aggregate
  all sampled results of array "arrayf" by averaging it.
  The last sampled number is generated by the tuning process
  and will not be counted.

- make
- ./run

---------------------------------------------------------------------------------

3.2 Example 2
- cd /path/to/WBTuner/test/examples/example2
- Edit Makefile path
  - line 6: LDLIB = -L/path/to/WBTuner/dplib
  - line 9: INCPATH = -I/path/to/WBTuner/dplib
- Primitives explanation:
  - dpExp
    Arg1: context used to load exposed value in user's callback
    Arg2: variable's type; int
    Arg3: variable
  - dpAggregate
    Arg6: aggregation strategy, use user's callback
    Arg7: user's callback executed before real callback
    Arg8: user's callback executed after real callback
    Arg9: user's real callback, defined in callback.c
    
- Explanation:
  dpExp at line 12 is used to load nmemb for use in user's callback function.
  dpAggregate at line 20 use user's callback function instead of 
  default aggregation strategy. Thus, the stg is set to A_USER_CB.

  In the callback function, user can check 10 sampled results of an array.
  Here, the 0-th element of each array is dumped. The 5th result 
  is splitted to a new tuning process with dpuSplit primitive. The 8th
  result is copied to the final result of the original tuning process.

- make
- ./run

---------------------------------------------------------------------------------

3.3 Example 3
- cd /path/to/WBTuner/test/examples/example3
- Edit Makefile path
  - line 6: LDLIB = -L/path/to/WBTuner/dplib
  - line 9: INCPATH = -I/path/to/WBTuner/dplib
- Primitives explanation:
  - dpCheck
  Arg1: user's callback for check, defined in callback
  Arg2: # checking variables
  Arg3: 1st checking variable
  Arg4: 2nd checking variable
    
- Explanation:
  dpCheck at line 15 is used check the value of variable "f".
  In the callback, if the sampled value is less than 1, then
  0 is returned so the result will be discarded and 
  replaced by a new sample. The aggregation result will be 
  larger than 1.
  
- make
- ./run

---------------------------------------------------------------------------------

3.4 Example 4
- cd /path/to/WBTuner/test/examples/example4
- Edit Makefile path
  - line 6: LDLIB = -L/path/to/WBTuner/dplib
  - line 9: INCPATH = -I/path/to/WBTuner/dplib
- Primitives explanation:
  - dpSync
  Arg1: target sync variable
  Arg2: variable's element type; float
  Arg3: variable's element size
  Arg4: # elements
  Arg5: user's sync callback, defined in callback.c
    
- Explanation:
  To do sync, we add one more random annotation to sample "x".
  dpSync is called at line 19 to sync the value of "x".
  In sync callback "cbSync", if two child process have the 
  same value for "x", then two new tuning processes will be 
  spawned and continue to execute.
  
- make
- ./run

---------------------------------------------------------------------------------

3.5 Example 5
- cd /path/to/WBTuner/test/examples/example5
- Edit Makefile path
  - line 6: LDLIB = -L/path/to/WBTuner/dplib
  - line 9: INCPATH = -I/path/to/WBTuner/dplib
- Primitives explanation:
  - dpSampling
  Arg3: sampling strategy, cross validation is being used here
  Arg4: K
  Arg5: target training file
  Arg6: validation callback
  Arg7: accept probability callback
    
- Explanation:
  To show how cross validation works clearly, we only sample once
  here. The training data contains 10 entries, so 9 entries will be
  the training set and 1 entry will be the validation set.
  WBTuner will split the data into different training and validation 
  sets for each of the SVG processes.
  
  In validation callback, the validation set data is read and 
  multiplied by the sampled value. The result is being returned
  as the validation error. The final validation error of each sample
  is the average of the validation errors from the SVG processes.
  
  In aggregation callback, the validation error of each sample
  is dumped.
  
- make
- ./run

---------------------------------------------------------------------------------

3.6 Drone tuning result

- Tuning drone requires tedious system setup. Thus, we will show the tuning result 
  directly in the video. As metioned in the paper, the drone flies along the 
  zigzag shaped path in the testing mission. The following three videos show
  the flying behavior of PX4, default ArduPilot, and tuned Ardupilot. Because
  the 3D view would incurs much higher overhead, which results in frame lost,
  we only demo the flying results in bird's-eye view. We also show the 
  motors' speed after each simulation. 

- PX4
  - https://drive.google.com/open?id=0BxgPTM7nEUyCYnRxS2FSN2JRbEE
  - Explanation:
    Drone controlled by this software flies with the target behavior we want to 
    mimic. As shown in the video, at each way point, PX4 avoids changing the 
    orientation as much as possible.
    Mission time: 82 - 0 = 82s
  
- Default ArduPilot
  - https://drive.google.com/open?id=0BxgPTM7nEUyCcTFKdjM4RVNrMk0
  - Explanation:
    As mentioned in the paper, drone controlled by default ArduPilot will turns 
    toward to its next way point before moving towards it. Thus, the the flying 
    speed of default ArduPilot is slower then PX4. For ArduPilot, the motors' 
    speed equal to 100 rad/s means drone does not in the flying mission, so 
    mission time should be calculated after/before the motors' speed increase 
    from/drop to 100 rad/s.
    Mission time: 125 - 20 = 105s
    
- Tuned ArduPilot
  - https://drive.google.com/open?id=0BxgPTM7nEUyCYmVPdzBtMnoyT1U
  - Explanation:
    After tuning, the tuned parameters changed the ArduPilot's behavior 
    considerably. Thus, the flying behavior of tuned ArduPilot is
    quite similar to PX4, especially the tuning behavior at each way point.
    Mission time: 104 - 20 = 84s


